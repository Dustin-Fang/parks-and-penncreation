Optimization of All Queries:

(4/28/22)
On Thursday morning, the four of us met with Rajvi to talk about how to create indexes
on our datasets. We also talked about how using materialized views could help with
optimization. Because our WeatherEvents dataset is so large, our group found that relational
algebra optimization was insufficient in getting queries to run in under a minute.

Our first indexing attempt in the meeting actually slowed down the query. Rajvi recommended
we use the "explain" key word to help see where our query was getting stuck. We tried
building an index on start time for weather events. More attempts resulted in similar 
runtimes to the original query.



Ari's Query Optimization Log:

(4/27/22)
My complex query initially took 2m 15s 349ms to execute. In my first
optimization attempt, I tried pushing the projections down and moving
the joins up.

Before:
-- Count and order the weather events
WITH WeatherTypes AS (
    WITH SpeciesLocations AS (
        SELECT S.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
        FROM Species S JOIN Parks P on S.ParkId = P.ParkId
        WHERE S.ScientificName = 'Lynx rufus'
        )
    SELECT WE.WeatherType AS WeatherType
    FROM WeatherEvents WE JOIN SpeciesLocations SL ON ABS(WE.Latitude - SL.Latitude) <= 5.0 AND ABS(WE.Longitude - SL.Longitude) <= 5.0
    WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31')
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

After:
-- Optimized query attempt 1 (1m 37s 736ms)
WITH SpeciesSubset AS (
    SELECT S.ParkId AS ParkId, S.ScientificName AS ScientificName
    FROM Species S
    WHERE S.ScientificName = 'Lynx rufus'
    ),
     ParksSubset AS (
         SELECT P.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
         FROM Parks P
     ),
     SpeciesLocations AS (
         SELECT SS.ParkId AS ParkId, PS.Latitude AS Latitude, PS.Longitude AS Longitude
         FROM SpeciesSubset SS JOIN ParksSubset PS on SS.ParkId = PS.ParkId
         ),
     WeatherEventsSubset AS (
         SELECT WE.WeatherType AS WeatherType, WE.Latitude AS Latitude, WE.Longitude AS Longitude
         FROM WeatherEvents WE
         WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31'
     ),
     WeatherTypes AS (
         SELECT WES.WeatherType AS WeatherType
         FROM WeatherEventsSubset WES JOIN SpeciesLocations SL ON ABS(WES.Latitude - SL.Latitude) <= 5.0 AND ABS(WES.Longitude - SL.Longitude) <= 5.0)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

As noted in the comment, this cut down the runtime about 38 seconds. Still,
I realized I made a couple small mistakes, so I updated those, which brought
the time down by another 8 seconds.

-- Optimized query attempt 2 (1m 30s 786ms)
WITH SpeciesSubset AS (
    SELECT S.ParkId AS ParkId
    FROM Species S
    WHERE S.ScientificName = 'Lynx rufus'
    ),
     SpeciesLocations AS (
         SELECT SS.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
         FROM SpeciesSubset SS JOIN Parks P on SS.ParkId = P.ParkId
         ),
     WeatherEventsSubset AS (
         SELECT WE.WeatherType AS WeatherType, WE.Latitude AS Latitude, WE.Longitude AS Longitude
         FROM WeatherEvents WE
         WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31'
     ),
     WeatherTypes AS (
         SELECT WES.WeatherType AS WeatherType
         FROM WeatherEventsSubset WES JOIN SpeciesLocations SL ON ABS(WES.Latitude - SL.Latitude) <= 5.0 AND ABS(WES.Longitude - SL.Longitude) <= 5.0)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;



Gian's Query Optimization Log:



Dustin's Query Optimization Log:



Shanna's Query Optimization Log:
For MS3, my initial query took > 15mins.

WITH filtered AS (
    SELECT ParkId, ParkName, WeatherType, EventId, StartTime
    FROM WeatherEvents w JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
    WHERE StartTime LIKE '2021%'
), ex AS (
         SELECT EventId, ParkName, WeatherType,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Rain')) / COUNT(EventId) as PercentBad
         FROM filtered
        GROUP BY ParkId
        HAVING PercentBad < 30
    )
    SELECT EventId, ParkName,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Snow')) / COUNT(EventId) as PercentGood
    FROM filtered
    GROUP BY ParkId
    HAVING PercentGood > 30 AND ParkName IN (SELECT ParkName from ex);

ATTEMPT 2!
Using optimization techniques from class (using smaller table as outer in join, 
pushing projections down and JOINS up, etc.) I was able to bring this down to 
~6min 25s

WITH filteredEvents AS (
    SELECT *
    FROM WeatherEvents
    WHERE StartTime LIKE '2021%'
), filtered AS (
    SELECT ParkId, ParkName, WeatherType, EventId, StartTime
    FROM filteredEvents w
             JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
), ex AS (
         SELECT EventId, ParkName, WeatherType,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Rain')) / COUNT(EventId) as PercentBad
         FROM filtered
        GROUP BY ParkId
        HAVING PercentBad < 30
    )
    SELECT EventId, ParkName,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Snow')) / COUNT(EventId) as PercentGood
    FROM filtered
    GROUP BY ParkId
    HAVING PercentGood > 30 AND ParkName IN (SELECT ParkName from ex);

Finally, after fixing some more of the logic, and using a view, I was able to bring this time down to 
~4min 49s

CREATE VIEW filteredEvents AS
SELECT WeatherType, EventId, StartTime, Latitude, Longitude
FROM WeatherEvents
WHERE StartTime LIKE '2021%'; # 480 ms

WITH filtered AS (SELECT EventId, p.ParkName, WeatherType
    FROM filteredEvents w
             JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
), cts AS (
         SELECT EventId, ParkName, WeatherType, COUNT(EventId) as CT
         FROM filtered
            GROUP BY ParkName
     ) , good AS (SELECT x.ParkName, CT, PercentGood / CT as goodAvg
        FROM cts e JOIN (SELECT ParkName, COUNT(EventId) as PercentGood FROM filtered WHERE WeatherType='Rain' GROUP BY ParkName) x
        ON x.ParkName=e.ParkName)

        SELECT g.ParkName, PercentBad / CT as badAvg, goodAvg
            from good g JOIN (SELECT ParkName, COUNT(EventId) as PercentBad FROM filtered WHERE WeatherType='Snow' GROUP BY ParkName) y
                ON g.ParkName = y.ParkName
        HAVING badAvg < 0.3 AND goodAvg > 0.3;

This is still very very suboptimal, and I'm working to make it better. My fastest solution
involved creating a new table of filteredEvents, rather than a view. Creating the table takes ~1 min 30s.
Using an index on Longitude and latitude on this new table, the query itself takes ~30s to run.
Then, I'd have to drop the newly made table. This is less than ideal, so I haven't included that query here,
but I'm currently working on using a similar logic.. perhaps caching the filteredEvents result, or finding
a way to use a TEMPORARY TABLE instead. 