Optimization of All Queries:

(4/28/22)
On Thursday morning, the four of us met with Rajvi to talk about how to create indexes
on our datasets. We also talked about how using materialized views could help with
optimization. Because our WeatherEvents dataset is so large, our group found that relational
algebra optimization was insufficient in getting queries to run in under a minute.

Our first indexing attempt in the meeting actually slowed down the query. Rajvi recommended
we use the "explain" key word to help see where our query was getting stuck. We tried
building an index on start time for weather events. More attempts resulted in similar 
runtimes to the original query.



Ari's Query Optimization Log:

(4/27/22)
My complex query initially took 2m 15s 349ms to execute. In my first
optimization attempt, I tried pushing the projections down and moving
the joins up.

Before:
-- Count and order the weather events
WITH WeatherTypes AS (
    WITH SpeciesLocations AS (
        SELECT S.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
        FROM Species S JOIN Parks P on S.ParkId = P.ParkId
        WHERE S.ScientificName = 'Lynx rufus'
        )
    SELECT WE.WeatherType AS WeatherType
    FROM WeatherEvents WE JOIN SpeciesLocations SL ON ABS(WE.Latitude - SL.Latitude) <= 5.0 AND ABS(WE.Longitude - SL.Longitude) <= 5.0
    WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31')
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

After:
-- Optimized query attempt 1 (1m 37s 736ms)
WITH SpeciesSubset AS (
    SELECT S.ParkId AS ParkId, S.ScientificName AS ScientificName
    FROM Species S
    WHERE S.ScientificName = 'Lynx rufus'
    ),
     ParksSubset AS (
         SELECT P.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
         FROM Parks P
     ),
     SpeciesLocations AS (
         SELECT SS.ParkId AS ParkId, PS.Latitude AS Latitude, PS.Longitude AS Longitude
         FROM SpeciesSubset SS JOIN ParksSubset PS on SS.ParkId = PS.ParkId
         ),
     WeatherEventsSubset AS (
         SELECT WE.WeatherType AS WeatherType, WE.Latitude AS Latitude, WE.Longitude AS Longitude
         FROM WeatherEvents WE
         WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31'
     ),
     WeatherTypes AS (
         SELECT WES.WeatherType AS WeatherType
         FROM WeatherEventsSubset WES JOIN SpeciesLocations SL ON ABS(WES.Latitude - SL.Latitude) <= 5.0 AND ABS(WES.Longitude - SL.Longitude) <= 5.0)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

As noted in the comment, this cut down the runtime about 38 seconds. Still,
I realized I made a couple small mistakes, so I updated those, which brought
the time down by another 8 seconds.

-- Optimized query attempt 2 (1m 30s 786ms)
WITH SpeciesSubset AS (
    SELECT S.ParkId AS ParkId
    FROM Species S
    WHERE S.ScientificName = 'Lynx rufus'
    ),
     SpeciesLocations AS (
         SELECT SS.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
         FROM SpeciesSubset SS JOIN Parks P on SS.ParkId = P.ParkId
         ),
     WeatherEventsSubset AS (
         SELECT WE.WeatherType AS WeatherType, WE.Latitude AS Latitude, WE.Longitude AS Longitude
         FROM WeatherEvents WE
         WHERE WE.StartTime >= '2021-01-01' AND WE.EndTime <= '2021-12-31'
     ),
     WeatherTypes AS (
         SELECT WES.WeatherType AS WeatherType
         FROM WeatherEventsSubset WES JOIN SpeciesLocations SL ON ABS(WES.Latitude - SL.Latitude) <= 5.0 AND ABS(WES.Longitude - SL.Longitude) <= 5.0)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

(5/2/22)
Based on Dustin's optimizations, I changed from using WeatherEvents to our filteredEvents
table and went from using ABS to other operations. This got the runtime down to about 28
seconds, which is 20.5% of the original runtime.

-- Optimized query attempt 3 (27s 759ms)
WITH SpeciesSubset AS (
    SELECT S.ParkId AS ParkId
    FROM Species S
    WHERE S.ScientificName = 'Lynx rufus'
    ),
     SpeciesLocations AS (
         SELECT SS.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
         FROM SpeciesSubset SS JOIN Parks P on SS.ParkId = P.ParkId
         ),
     WeatherEventsSubset AS (
         SELECT FE.WeatherType AS WeatherType, FE.Latitude AS Latitude, FE.Longitude AS Longitude
         FROM filteredEvents FE
     ),
     WeatherTypes AS (
         SELECT WES.WeatherType AS WeatherType
         FROM WeatherEventsSubset WES JOIN SpeciesLocations SL ON
             WES.Latitude <= 5.0 + SL.Latitude AND WES.Latitude >= SL.Latitude - 5.0 AND
             WES.Longitude <= 5.0 + SL.Longitude AND WES.Longitude >= SL.Longitude - 5.0)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM WeatherTypes WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

(5/7/22)
-- Optmization query attempt 4 (29s)
Made changes to accomadate for new range searching

WITH speciesSubset AS (
    SELECT S.Category, S.ParkId
    FROM Species S
    WHERE S.Category = `${category}`
  ), parkSubset AS (
      SELECT P.ParkID, P.Latitude, P.Longitude
      FROM Parks P
  ), joinedParkSpecies AS (
      SELECT SS.Category
      FROM speciesSubset SS JOIN parkSubset PS ON PS.ParkID = SS.ParkID
      WHERE PS.Latitude >= `${lowerLat}` AND PS.Latitude <= `${upperLat}`
          AND PS.Longitude >= `${lowerLng}` AND PS.Longitude <= `${upperLng}`
  ), joinedAllSubset AS (
      SELECT JPS.Category, WS.WeatherType, WS.Duration
      FROM joinedParkSpecies JPS JOIN
          (SELECT WeatherType, Duration, Latitude, Longitude, StartTime, EndTime FROM filteredEvents) WS
      WHERE WS.Latitude >= `${lowerLat}` AND WS.Latitude <= `${upperLat}`
          AND WS.Longitude >= `${lowerLng}` AND WS.Longitude <= `${upperLng}` AND
          (EXTRACT(MONTH FROM WS.StartTime) BETWEEN 1 AND 12)
          AND (EXTRACT(MONTH FROM WS.EndTime) BETWEEN 1 AND 12)
  )
SELECT JAS.Category, JAS.WeatherType, SUM(JAS.Duration) as TotalTime
FROM joinedAllSubset as JAS
GROUP BY JAS.WeatherType
ORDER BY TotalTime DESC;



Gian's Query Optimization Log:

High query time >30 mins

SELECT S.*, W.WeatherType, W.Severity, SUM(W.Duration) as TotalTime
FROM (SELECT * FROM WeatherEvents where Latitude <= 40.0 AND Longitude <= -70.0 AND Longitude >= -120.0) AS W
JOIN Species S JOIN Parks P on P.ParkID = S.ParkID AND ABS(W.Latitude - P.Latitude) <= 1.0 AND ABS(W.Longitude - P.Longitude) <= 1.0
WHERE (EXTRACT(MONTH FROM W.StartTime) BETWEEN 6 AND 8) AND (EXTRACT(MONTH FROM W.EndTime) BETWEEN 6 AND 8)
GROUP BY W.WeatherType, W.Severity
ORDER BY TotalTime DESC;

(5/3/22)
After a proposal in an email from Rajvi, I tried replacing my "WITH AS" statements with
nested subqueries. However, this actually made my query two seconds longer than the
previous attempt.

-- Optimized query attempt 4 (29s 359ms)
SELECT WT.WeatherType AS WeatherType, COUNT(WT.WeatherType) AS Occurances
FROM (
    SELECT WES.WeatherType AS WeatherType
    FROM (
        SELECT FE.WeatherType AS WeatherType, FE.Latitude AS Latitude, FE.Longitude AS Longitude
        FROM filteredEvents FE
        ) AS WES
        JOIN (
            SELECT SS.ParkId AS ParkId, P.Latitude AS Latitude, P.Longitude AS Longitude
            FROM (
                SELECT S.ParkId AS ParkId
                FROM Species S
                WHERE S.ScientificName = 'Lynx rufus'
                ) AS SS
                JOIN Parks P on SS.ParkId = P.ParkId
        ) AS SL
            ON
                WES.Latitude <= 5.0 + SL.Latitude AND WES.Latitude >= SL.Latitude - 5.0 AND
                WES.Longitude <= 5.0 + SL.Longitude AND WES.Longitude >= SL.Longitude - 5.0)
    AS WT
GROUP BY WT.WeatherType
ORDER BY COUNT(WT.WeatherType) DESC;

I'm sticking with attempt 3 and adding that version to the document where we're recording
our queries.


Dustin's Query Optimization Log:
(4/28/22)
For MS3, my intial query took ~4mins

Adding projection and selection pushdown brought it to 1m 14s with the following query:
WITH Highest_Occurence_Park AS (
    WITH TypeEachPark As (
    SELECT ParkId, COUNT(EventId) as NumOfEventsByPark
    FROM (SELECT EventId, Latitude, Longitude, WeatherType from WeatherEvents) as w
        JOIN (SELECT Latitude, Longitude, ParkId FROM Parks) as p on
        ABS(w.Latitude - p.Latitude) <= 5.0 AND ABS(w.Longitude - p.Longitude) <= 5.0
    WHERE WeatherType = 'Cold'
    GROUP BY ParkId
    )
        SELECT T.ParkId, (T.NumOfEventsByPark / (SELECT SUM(NumOfEventsByPark) FROM TypeEachPark)) as WeatherPercentage
        FROM TypeEachPark as T
        ORDER BY WeatherPercentage DESC
        LIMIT 1
    )
SELECT S.SpeciesId, CommonName
FROM (SELECT SpeciesId, ParkId FROM Species) S JOIN (SELECT ParkId FROM Highest_Occurence_Park) P2 on P2.ParkId = S.ParkId
    JOIN CommonNames CN on S.SpeciesId = CN.SpeciesId;

Attempt 1: Adding index on Latitude and Longitude in the WeatherEventsTable: took ~1m 35s with above query

Attempt 2: Reducing size of joined weatherEvent table by limiting weather events to 2021 and later - ~1m 23s
WITH filteredEvents AS (
    SELECT EventId, Latitude, Longitude, WeatherType, StartTime
    FROM WeatherEvents
    WHERE StartTime >= '2021-01-01 00:00:00.000'
), Highest_Occurence_Park AS (
    WITH TypeEachPark As (SELECT ParkId, COUNT(EventId) as NumOfEventsByPark
    FROM (SELECT EventId, Latitude, Longitude, WeatherType FROM (filteredEvents)
        ) as w
        JOIN (SELECT Latitude, Longitude, ParkId FROM Parks) as p on
        ABS(w.Latitude - p.Latitude) <= 5.0 AND ABS(w.Longitude - p.Longitude) <= 5.0
    WHERE WeatherType = 'Cold'
    GROUP BY ParkId
    )
        SELECT T.ParkId, (T.NumOfEventsByPark / (SELECT SUM(NumOfEventsByPark) FROM TypeEachPark)) as WeatherPercentage
        FROM TypeEachPark as T
        ORDER BY WeatherPercentage DESC
        LIMIT 1
    )
SELECT S.SpeciesId, CommonName
FROM (SELECT SpeciesId, ParkId FROM Species) S JOIN (SELECT ParkId FROM Highest_Occurence_Park) P2 on P2.ParkId = S.ParkId
    JOIN CommonNames CN on S.SpeciesId = CN.SpeciesId;

Attempt 3: Adding index of Latitude and Longitude in parks table with the above query - ~1m 22s

Attempt 4: Switching to better range search instead of using ABS to take advantange of Indexes. Also stored
filtered events as a permanent table into the database. Adding Longitude and Latitude as indexes to filteredEvents
made query times significantly slower. Using no index of the Parks or filteredEvents table seemed aid query time.
Query times range based on the type of weather chosen:
All done with limit 1: Can increase time/results with more time

With Highest_Occurence_Park AS (
    WITH TypeEachPark As (SELECT ParkId, COUNT(EventId) as NumOfEventsByPark
    FROM (SELECT EventId, Latitude, Longitude, WeatherType FROM (filteredEvents)
        ) as w
        JOIN (SELECT Latitude, Longitude, ParkId FROM Parks_no_indexes) as p on
        w.Latitude <= 5.0 + p.Latitude AND w.Latitude >= p.Latitude - 5.0 AND
        w.Longitude <= 5.0 + p.Longitude AND w.Longitude >= p.Longitude - 5.0
    WHERE WeatherType = ${WeatherType}
    GROUP BY ParkId
    )
        SELECT T.ParkId, (T.NumOfEventsByPark / (SELECT SUM(NumOfEventsByPark) FROM TypeEachPark)) as WeatherPercentage
        FROM TypeEachPark as T
        ORDER BY WeatherPercentage DESC
        LIMIT 1
    )
SELECT S.SpeciesId, CommonName
FROM (SELECT SpeciesId, ParkId FROM Species) S JOIN (SELECT ParkId FROM Highest_Occurence_Park) P2 on P2.ParkId = S.ParkId
    JOIN CommonNames CN on S.SpeciesId = CN.SpeciesId;

WeatherType:
'Cold': ~1s 865ms
'Fog': ~8s 743ms
'Hail': ~947ms
'Rain': ~17s 309ms
'Snow': ~4s 324ms
'Storm': ~1s 118ms
'Precipit': Forgot to test



Shanna's Query Optimization Log:
(4/28/22)
For MS3, my initial query took > 15mins.

WITH filtered AS (
    SELECT ParkId, ParkName, WeatherType, EventId, StartTime
    FROM WeatherEvents w JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
    WHERE StartTime LIKE '2021%'
), ex AS (
         SELECT EventId, ParkName, WeatherType,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Rain')) / COUNT(EventId) as PercentBad
         FROM filtered
        GROUP BY ParkId
        HAVING PercentBad < 30
    )
    SELECT EventId, ParkName,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Snow')) / COUNT(EventId) as PercentGood
    FROM filtered
    GROUP BY ParkId
    HAVING PercentGood > 30 AND ParkName IN (SELECT ParkName from ex);

ATTEMPT 2!
Using optimization techniques from class (using smaller table as outer in join, 
pushing projections down and JOINS up, etc.) I was able to bring this down to 
~6min 25s

WITH filteredEvents AS (
    SELECT *
    FROM WeatherEvents
    WHERE StartTime LIKE '2021%'
), filtered AS (
    SELECT ParkId, ParkName, WeatherType, EventId, StartTime
    FROM filteredEvents w
             JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
), ex AS (
         SELECT EventId, ParkName, WeatherType,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Rain')) / COUNT(EventId) as PercentBad
         FROM filtered
        GROUP BY ParkId
        HAVING PercentBad < 30
    )
    SELECT EventId, ParkName,
           (SELECT COUNT(EventId) FROM filtered WHERE WeatherType IN ('Snow')) / COUNT(EventId) as PercentGood
    FROM filtered
    GROUP BY ParkId
    HAVING PercentGood > 30 AND ParkName IN (SELECT ParkName from ex);
    
ATTEMPT 3!
Finally, after fixing some more of the logic, and using a view, I was able to bring this time down to 
~4min 49s

CREATE VIEW filteredEvents AS
SELECT WeatherType, EventId, StartTime, Latitude, Longitude
FROM WeatherEvents
WHERE StartTime LIKE '2021%'; # 480 ms

WITH filtered AS (SELECT EventId, p.ParkName, WeatherType
    FROM filteredEvents w
             JOIN Parks p on
                ABS(w.Latitude - p.Latitude) <= 1.0 AND ABS(w.Longitude - p.Longitude) <= 1.0
), cts AS (
         SELECT EventId, ParkName, WeatherType, COUNT(EventId) as CT
         FROM filtered
            GROUP BY ParkName
     ) , good AS (SELECT x.ParkName, CT, PercentGood / CT as goodAvg
        FROM cts e JOIN (SELECT ParkName, COUNT(EventId) as PercentGood FROM filtered WHERE WeatherType='Rain' GROUP BY ParkName) x
        ON x.ParkName=e.ParkName)

        SELECT g.ParkName, PercentBad / CT as badAvg, goodAvg
            from good g JOIN (SELECT ParkName, COUNT(EventId) as PercentBad FROM filtered WHERE WeatherType='Snow' GROUP BY ParkName) y
                ON g.ParkName = y.ParkName
        HAVING badAvg < 0.3 AND goodAvg > 0.3;


ATTEMPT 4! After using a view of filtered events, my other optimization attempts involved using temporary tables, and attempting to cache the result, but ultimately the most effective for this and the other complex queries was to create a separate table with just the weather events from 2021. 

table creation: 

CREATE TABLE filteredEvents AS
SELECT *
FROM WeatherEvents
WHERE StartTime LIKE '2021%'; # 1m 17s, 1,200,000+ rows

using this table, my query then takes ~30seconds

WITH filtered AS (SELECT EventId, p.ParkName, p.State, WeatherType
    FROM filteredEvents fe
    JOIN Parks p on
    ABS(fe.Latitude - p.Latitude) <= 1.0 AND ABS(fe.Longitude - p.Longitude) <= 1.0
),
     totals AS (
         SELECT EventId, ParkName, State, WeatherType, COUNT(EventId) as CT
         FROM filtered
         GROUP BY ParkName
     ),
     goodEvents AS (
        SELECT totals.ParkName, totals.State, CT, totalGood / CT as goodAvg
        FROM totals JOIN
            (SELECT ParkName, COUNT(EventId) as totalGood FROM filtered WHERE WeatherType='Rain' GROUP BY ParkName) x
                ON x.ParkName=totals.ParkName)

        SELECT goodEvents.ParkName, goodEvents.State, PercentBad / CT as badAvg, goodAvg
        FROM goodEvents JOIN
            (SELECT ParkName, COUNT(EventId) as PercentBad FROM filtered WHERE WeatherType='Snow' GROUP BY ParkName) y
                ON goodEvents.ParkName = y.ParkName
        HAVING badAvg < 0.3 AND goodAvg > 0.3;
        

I also tried using cross product instead of a JOIN in the longitude/latitude calculations, but this increased the query slightly.
My query time was also increased when I tried using nested joins, so I decided to stick with Attempt 4.

